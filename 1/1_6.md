# 1.6 分组延时,丢失,吞吐量

## 分组时延的类型

### 节点处理延时

- 检查分组首部，并决定将该分组导向何处
- 检查bit级的差错

处理后，路由器将该分组引向通往下一个链路之前的队列

### 排队时延

- 也就是在队列里等待传输的时间
- 取决于路由器的拥塞程度

### 传输时延

若一条链路速率：$$R=1{\  Mbps}$$，那么**发出**一个bit就需要$$\frac 1 R =1{\  us}$$的时间

若有个包大：$$L=1{\  Mbits}$$，那么把这个包全部**发出**就需要$$\frac L R =1{\  s}$$

### 传播时延

当一个bit被推到了链路，它要从链路的起点传播到下一个路由器，这段时间就叫传播时延

即：

- d=物理链路长度
- s=在物理媒体上的传播速度(譬如光纤中的光信号：$$2\times10^8 { m/s}$$)

- 传播延时即为：$$d/s$$

### 类比

诶我偏不用车队类比。

把路由器当作炮兵阵地(可惜阵地里只有一门炮)，你是炮兵阵地的意大利超级人工智能自动开炮系统

- 处理延时：你查看炮弹有没有问题，查看开炮命令要你打哪里。(设1s)
- 排队延时：假如一下子有6炮要开，很显然，要开6波炮，后面的开炮命令会有延迟
- 传输延时：你把炮弹装填到炮膛里，点燃引信直到炮弹飞出所需的时间(设2s)
- 传播延时：炮弹在天上飞的时间(设100s)

(有趣的事，如果这样比喻，其实你的炮弹也是别的炮兵阵地打来的，你打出去的炮弹也会给另外一个炮兵阵地拿来开炮)

![](../image/kaipao.jpg)

## 节点延时

$$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$$

- $$d_{proc}$$处理延时
  - 微秒级或更低

- $$d_{queue}$$排队延时
  - 取决于拥塞程度
  - 毫秒～微秒

- $$d_{trans}$$传输时延
  - =$$L/R$$，对低速率链路(R小)而言很大(比如拨号)
  - 微妙～毫秒

- $$d_{prop}$$传播延时
  - 几微秒～几百毫秒

### traceroute

Linux下，

`traceroute 81.68.182.133` 即可知道你访问我的博客，通过了哪些路由器，**往返时延**(Round Trip Time,RTT)是多少

![](../image/traceroute.png)

#### 原理

一个分组包含头部(head)和数据，头部中有一个生存时间TLL，TLL每经过一个路由器就会被减一，当TLL的值为0时，路由器会根据ICMP协议回报原地址一个报文，表示分组过期。

- ICMP和UDP一样，不可靠
- traceroute，通过将每次分组的TLL分别置为1，2，3，4...以收到每个路由器的报文
- 当分组抵达目标主机端口时，目标主机发现端口并没有应用程序在守候分组，于是也会通过ICMP给源地址发送一个报文

## 排队延时计算与丢包

- R 链路带宽(bps)
- L 分组长度(bits) (或者其实我觉得应该写作bits/pkt)
- a 分组抵达队列的平均速度(pkt/s)

流量强度$$=\frac{L a}{R}$$

![](../image/traffic-intensity.png)

这个图所描述的情况，**建立在队列可以无限大的情况下**

当流量强度趋于1的时候，平均延时会变得很大。

实际情况中，设计系统时：流量强度不能大于1(也不能等于1)，否则平均排队延时将趋于无穷大

为什么：

- 大于1时显然队列长度趋于无穷大
- 等于1时，实际情况下，考虑每两个分组之间的时间间距并不是相等的(也就是说可能某一时间的速度大于a，某一时间的速度又小于a)(速度小于a的时候而且队列为空时，路由器只能被迫发呆，我们又知道，由于平均是1，你闲了一波后面一波就要忙了，这种发呆的时间过去之后，速度大于a以后，队列就会突然累计到一个很大的长度，在无限的时间长度下，最大的发呆时间也会趋于无穷大，因此队列长度会趋于无穷大)

**当队列不可以无限大时(现实情况)**

- 显然我们造不出无限大的buffer
- 队列满了以后，新来的分组就会被路由器丢弃(drop)，或称该分组丢失了(lost)

- 当流量强度趋于1时，就可能导致某一时间a很大，导致队列被填满，出现丢包
- 当流量强度大于1时，丢包一定会发生
- **制造很大的buffer也没有意义**
  - 很大的buffer意味着如果buffer全用上了，那么最后的分组将会承受巨大的排队延时(夸张一点，几天)，还不如丢了

- 当丢包发生时，前一个节点或者端系统可能重传，或者根本不重传
  - 节点可能基于一些链路层的保障，重传这个包(可靠的链路)
    - 有些线路本身物理层就几乎不会出错，就倾向于不借助链路层 保障包的传输
    - 有些线路物理层非常不可靠(比如一些无线技术)，如果不在链路层作保障，会导致可靠性非常差
      - 可靠性非常差是我们不希望发生的，多个链路的不可靠是会“叠加”的
        - 要是UDP只有1%的可能性传递成功，那UDP恐怕烂了
  - 端系统可能基于TCP重传

## 吞吐量

从源端到目标端传输的速率(数据量/单位时间)

- 瞬间吞吐量(instantaneous throughput)：某一时间点的速率
- 平均吞吐量(average throughput)：一个长时间内的速率

注：吞吐量可以指某个网络节点，也可以指某个链路，甚至某个逻辑连接(上下文确定)

### 瓶颈

![](../image/bottleneck-throughput.png)

- $$R_i$$是每条链路的传输速率，端到端的平均吞吐为$$\min(R_1,R_2,...R_n)$$

### 等分

![](../image/share-throughput.png)

如果有多个连接共享一个链路，假定链路吞吐量为多个连接等分吞吐量，这样端到端平均吞吐其实应该是(U是每个链路被多少连接共享)：$$\min(R_1/U_1,R_2/U_2,...R_n/U_n)$$

- 意思是，即使一条链路吞吐量很大，如果有多个连接共享，也可能成为瓶颈
